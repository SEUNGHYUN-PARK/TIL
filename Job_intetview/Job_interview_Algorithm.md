JOB_INTERVIEW
=============

Algorithm
-------------

#### 참고

[Github-Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java)  

### 코딩 테스트를 위한 팁  
1. 문제를 분석하기위해 막 적어라  
    * 가만히 있는거보단 칠판에다 적어가면서 풀어라 -> 그럼 패턴이나 그런게 보일 수도 있음  
2. 조용히 스스로 풀려하지말고 면접관과 상호작용을 하려한다  
    * 문제를 풀면서 막힐거같으면 차라리 그냥 힌트를 물어봐라  
3. 알고리즘을 생각을 하라  
    * 대부분의 면접에서 요구하는 문제의 절반 이상을 해결하는데 도움이 되는 알고리즘 기법  
      * 정렬  
      * 분할정복  
      * DP / 메모이제이션  
      * 탐욕적 방법  
      * 재귀  
      * 특정 자료구조를 활용한 알고리즘  
4. 자료구조를 잘 활용해라  
    * 배열을쓸지  
    * 스택 / 큐를 쓸지  
    * Set을 쓸건지 / Map을 쓸건지  
    * Tree를 쓸건지  
    * 힙을 이용할건지  
    * 그래프를 이용할건지 알아서 판단 할 것  
5. 이전에 보안던 관련 문제와 해결방법에 대해 생각해봐라  
6. 문제를 작은 문제로 분해하여 수정  
    * 숲말고도 나무도 볼 줄 알아야한다  
7. 되돌아 오는 것을 두려워하지 마라  

### 문제 해결을 위한 전략적 접근  
* 코딩테스트의 목적  
  1. 문제 해결여부  
  2. 예외상황과 경계값 처리  
  3. 코드 가독성과 중복 제거 여부 등 코드품질  
  4. 언어 이해도  
  5. 효율성    
* 접근하기  
  1. 문제를 공격적으로 받아들이고 필요한 정보를 추가적으로 요구, 문제를 완벽히 이해하는게 우선  
  2. 해당 문제를 익숙한 용어로 재정의하거나 문제를 해결하기 위한 정보를 추출  
  3. 추상화 된 데이터를 기반으로 문제를 어떻게 해결할 지 계획을 세움, 이 때 알고리즘과 자료구조를 고민  
  4. 세운계획에 대해 검증을 해본다. 수도 코드 작성도 해당될 수 있고 출제자에게 의견을 물어볼 수 도 있다  
  5. 세운 계획으로 문제를 해결한다  
* 생각할 때  
  1. 비슷한문제  
  2. 단순한방법으로 시작해 점진적으로 개선  
  3. 작은 값을 생각  
  4. 그림으로 그려본다  
  5. 수식으로 표현  
  6. 순서를 강제  
  7. 뒤에서부터 생각해본다  

### 해결 방법 분류
* DP
  * 복잡한 문제를 간단한 여러 개의 하위문제로 나눠 푸는 방법
  * Top-Down / Bottom-up
  * Top-Down
    ```
    //Top-Down
    int fibonacci(int n)
    {
      if(n<=1)
         return n;
      else fibonacci(n-1)+fibonacci(n-2);
    }
    ```  
  * Top-Down with Memoization
    ```
    int memo[N+1];
    int fibonacci(int n)
    {
      if(n<=1)
        return n;
      else if(memo[n] != 0)
        return memo[n];
      else memo[n] = fibonacci(n-1)+fibonacci(n-2);
    }
    ```  
  * Bottom-up
    ```
    for(int i=2; i<=n; i++)
    {
      d[i] = d[i-1]+d[i-2];
    }
    ```  
  * 접근방법  
    1. 모든 답을 만들어보고 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계  
    2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 정수만을 반환하도록 부분 문제 정의를 변경  
    3. 재귀 호출의 입력 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄인다  
    4. 입력이 배열이거나 문자열인 경우, 가능하다면 적절한 변환을 통해 메모이제이션을 할 수 있도록 조정  
    5. 메모이제이션을 적용  
    <br></br>
* 탐욕법(Greedy)  
  * 각 단계마다 가장 좋은 방법만을 선택하는 해결 방법  
  * 동적 계획법보다 수행 시간이 훨씬 빠르기 때문에 유용  
  * 접근 방법
    * 문제의 답을 만드는 과정을 여러 조각으로 나눔  
    * 각 조각마다 어떤 우선순위롤 선택을 내려야 할지 결정  
    * 다음 두 속성이 적용되는지 확인  
      * 탐욕적 선택 속성 : 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재하는가  
      * 최적 부분 구조 : 각 단계에서 항상 최적의 선택만을 했을 때, 전체 최적해를 구할 수 있는가  

### 정렬 알고리즘 - 한번 보고 들어갈 것  
[Link](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm#sorting-algorithm)  

### 에라토스테네스 체  
[원리는 여기를참고](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Algorithm#prime-number-algorithm)  
```
int p[100]; // 소수 저장
int pn=0; // 소수의 개수
bool c[101]; // 지워졌으면 true
int n = 100; // 100까지 소수 for (int i=2; i<=n; i++) {
    if (c[i] == false) {
        p[pn++] = i;
        for (int j = i*i; j<=n; j+=i) {
            c[j] = true;
        }
    }
}
```
