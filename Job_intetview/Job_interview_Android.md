JOB_INTERVIEW
=============

Android
-------------

### 원본 및 참고  
[Android-Interview-QnA](https://github.com/devetude/Android-Interview-QnA)  

#### 안드로이드의 실행환경  
* 안드로이드는 크게 4가지 실행환경으로 구성  
* 가장 하단부터   
    * **리눅스 커널, 라이브러리, 어플리케이션 프레임워크, 어플리케이션 순서**  
    * 리눅스 커널  
    OS로 안드로이드 스마트폰의 다양한 하드웨어(화면, 카메라, 블루투스, GPS, 메모리 등)를 관리  
    * 라이브러리  
    안드로이드에 있는 다양한 기능(UI 처리, 미디어 프레임워크, 데이터베이스, 그래픽 처리, 웹 킷 등)을 소프트웨어적으로 구현해 놓은 환경 뿐만 아니라 안드로이드 앱을 구동해주는 dalvik 가상머신과 코어 라이브러리까지 포함하는 영역  
    * 어플리케이션 프레임워크  
    사용자의 입력(액티비티, 윈도우, 컨텐츠, 뷰, 노티피케이션 등) 또는 특정한 이벤트에 따라 출력을 담당하는 환경  
    * 애플리케이션  
    실제로 동작하는 앱이 설치되는 환경인 어플리케이션이 있음  

#### 안드로이드 프로젝트 구성요소  
* libs  
    * 프로젝트에서 사용하는 다양한 라이브러리 소스가 저장되는 공간  
* androidTest    
    * 앱의 일부 코드를 테스트하기 위한 소스를 저장하는 공간  
* java  
    * 자바 코드를 저장하는 공간  
    * 표준 자바와 동일하게 패키지를 이용한 하위 디렉토리 생성 방식을 사용  
* res  
    * 리소스(이미지, xml 레이아웃, 메뉴, 값)를 저장하는 공간  
* AndroidManifest.xml  
  * 앱에 대한 전체적인 정보를 담고있는 파일  
  * 앱의 구성요소와 실행 권한 정보 정의  
* project > build.gradle  
  * 프로그래머가 직접 작성한 그래들 빌드 스크립트 파일  
* gradle > build.gradle  
  * 앱에 대한 컴파일 버전정보, 의존성 프로젝트에 대한 정의가 되어있는 파일  

#### 안드로이드 매니페스트(android manifest) 파일에 대해서 설명  
* 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에 있어서 필요한 각종 정보가 저장되어있는 파일  
* 반드시 존재해야하는 xml 형식의 파일로 안드로이드 프로젝트의 최상위에 위치  

#### 디스플레이(display), 윈도우(window), 서피스(surface), 뷰(view), 뷰 그룹(view group), 뷰 컨테이너(view container), 레이아웃(layout)에 대해서 설명  
* 디스플레이  
  * 안드로이드 단말기가 가지고 있는 하드웨어 화면 의미  
* 윈도우  
  * 안드로이드에서 실행되는 앱이 그림(뷰)을 그릴 수 있는 영역을 의미  
  * 사용자로부터 입력(터치, 키) 이벤트를 받아 앱에 전달  
* 서피스   
  * 윈도우에 그림(뷰)을 그릴 때 그림이 저장되는 메모리 버퍼를 의미  
* 뷰  
  * 사용자 인터페이스를 구성하는 최상위 클래스  
  * 윈도우의 서피스를 이용하여 화면에 어떤 모양으로 그림을 그릴지와  
  발생하는 이벤트를 어떻게 처리할 것인지에 대한 기능을 구현  
  * 뷰 중에서 일반적인 제어 역할을 하고 있는 것들을 위젯이라 함  
* 뷰 그룹   
  * 여러개의 뷰를 포함하고 있는 뷰를 의미  
* 뷰 컨테이너  
  * 다른 뷰를 포함할 수 있는 뷰를 의미   
  대표적으로 리스트 뷰(list view), 스크롤 뷰(scroll view), 그리드 뷰(grid view) 등이 있음  
* 레이아웃
  * 뷰 그룹 중에서 내부에 뷰를 포함하고 있으면서 해당 뷰를 어떻게 윈도우에 배치할지 정의하는 관리자 역할을 하는 클래스    

#### 인플레이션(inflation)  
* xml 레이아웃 파일로 정의한 정보를 런타임에 setContentView 메소드가 호출됨에 따라 메모리 상에 객체로 만들어주는 과정  
* 이 과정에서 xml 레이아웃 파일에서 뷰에 id를 설정하고 해당 id가 R.java 파일에 주소 값으로 환원되며 findViewById 메소드와 id를 이용하여 코드 상으로 뷰 객체를 가져와 제어할 수 있음  

#### 안드로이드의 4대 컴포넌트(component)  
* 액티비티, 서비스, 브로드캐스트 리시버, 콘텐트 프로바이더  
  * 액티비티  
    * 안드로이드에서 화면을 관리하고 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트  
  * 서비스  
    * 화면에서 보이지 않지만 특정한 기능을 백그라운드에서 수행하는 컴포넌트  
  * 브로드캐스트 리시버  
    * 특정 안드로이드에서 발생하는 특정 브로드캐스트 메세지를 처리하기 위한 컴포넌트  
  * 콘텐트 프로바이더  
    * 앱간 데이터의 공유를 위해 표준화된 인터페이스를 제공하는 컴포넌트  

#### 안드로이드 MVC 모델  
* 뷰는 화면에 실제로 보이는 구성을 만드는 영역으로 View 클래스를 상속하는 클래스를 이용하여 구성할 수 있음  
* 컨트롤러는 뷰와 모델을 서로 연결하며 제어하는 영역으로 액티비티, 서비스, 브로드캐스트 리시버, 프래그먼트로 구성  
* 모델은 앱의 다양한 데이터를 저장하는 역할로 SQLite를 이용한 DB, SharedPreference를 이용한 파일 시스템, 콘텐트 프로바이더가 있음  

#### 액티비티(activity)와 액티비티 생명주기  
* 액티비티의 개념  
  * 안도르이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트  

* 액티비티 추가  
  1. 부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가    
  2. 다음으로 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소드를 이용하여 여러개의 액티비티를 한꺼번에 실행할 수 있음  

* 액티비티 불러오는 과정  
    1. 부모 액티비티에서 자식 액티비티를 생성 및 호출  
    2. 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후 매니페스트 파일에서 해당 인텐트에 명시되어있는 액티비티를 찾고 어떻게 실행시켜야할지 결정  
    3. 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스에 인텐트를 복사하여 넘겨줌   
    그 외 자식 액티비티 내의 onCreate 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성함  

* 액티비티의 상태  
  * 액티비티는 크게 3가지 상태가 존재 <실행,일시중지,중지>  
  * 실행(running)  
    * 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태  
  * 일시 중지(paused)  
    * 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태 예를들어 대화상자가 위에 있어 일부가 가려져 있는 경우  
  * 중지 (stopped)  
    * 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태  

* 액티비티의 생명주기  
  ***1. 액티비티가 처음 만들어지면 onCreate 메소드가 호출되어 레이아웃 구성  
  2. onStart 메소드가 화면에 보이기 직전에 호출  
  3. onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됨  
  4. 이 3가지 메소드가 호출되어 액티비티는 실행 상태를 갖게됨  
  5. 포커스를 잃었을 때 onPause 메소드가 호출되고 일시 중지 상태가 됨  
  6. 일시 중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않는 경우 onStop 메소드가 호출되어 중지 상태가 됨  
  7. 정지 상태에서 다시 화면이 보이기 직전에 onRestart 메소드가 호출되고 onStart 메소드가 차례로 호출  
  8. finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy 메소드가 실행***  
  * 가끔은 일시 중지나 중지 상태에서 시스템이 메모리가 부족하다고 판단될 경우 onCreate 메소드부터 다시 해당 액티비티를 구동  
  * 이 경우 onStop, onResume 메소드 호출이 생략  
  * 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용하여 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해줄 수 있음  

#### 액티비티간 데이터 전달에서 임의의 클래스 객체를 바로 전달하지 못하는 이유 & 전달하기 위해서는 어떤 처리가 필요한가?  
  * 액티비티간 전달할 수 있는 데이터의 type은 보통 기본형으로 정해져있음  
  그 이유는 인텐트를 이용하여 액티비티의 데이터를 전달하는 과정에서 현재 실행중인 앱 프로세스가 시스템 프로세스로 실행중인 액티비티 매니저 서비스 프로세스에게 인텐트를 전달하기 때문  
  이 경우 프로세스간 통신이기 때문에 인텐트에 있는 값들을 복사하여 넘기는 방식으로 처리되기 때문에 객체 주소를 바로 넘기지 못하는 문제가 발생  
  ***따라서 이 문제를 해결하기 위해 자신이 임의로 만든 클래스 객체를 전달하기 위해서는 Serilizable이나 Parcelable 인터페이스를 상속받아 객체를 직렬화하여 넘기는 방식을 사용해야함***  

#### 부모 액티비티에서 자식 액티비티의 결과 값을 받아오기 위해 어떻게 해야하는가?  
  1. 먼저 부모 액티비티에서 startActivityForResult 메소드를 이용하여 인텐트와 리퀘스트 코드를 파라미터로 넘긴다  
  2. 자식 액티비티에서 setResult 메소드에 결과 코드와 데이터를 파라미터로 넘긴다.  
  3. 다시 부모 액티비티에서 onActivityResult 메소드를 오버라이딩하여 자식 액티비티에서 보낸 결과 코드와 데이터를 받아 처리하는 코드를 작성할 수 있다.  
  4. 이후 실행과정에서 자식 액티비티의 finish 메소드가 호출되면 부모 액티비티가 다시 화면에 나타나면서 onResume 메소드가 실행된다. 이때 onActivityResult 메소드가 작동하게 된다.  

#### 서비스(service)의 정의 및 특징 & 서비스 생명주기  
* 정의  
  * 백그라운드에서 실행되는 구성 요소  
* 특징  
  * 서비스는 사용자에게 보이는 화면이 존재하지 않으며, 정해지지 않은 시간 동안 운영  
  * 각각의 서비스는 매니페스트 파일에 서비스 태그를 이용하여 선언  
  * 서비스는 Service 클래스를 상속받아 onStartCommand 또는 onBind 메소드를 재정의하여 구현할 수 있음  
  * 서비스는 다른 구성 요소들처럼 메인 쓰레드에서 동작  
  * 따라서 CPU를 많이 사용하거나 대기 상태를 필요로 하는 경우 새로운 쓰레드를 이용하여 생성해야함  
  * 또한 서비스의 객체는 단말에서 오직 1개만 생성되어 관리함  
* 생명주기  
  1. 서비스가 startService 메소드로 실행되는 경우 서비스가 생성될 때 onCreate 메소드가 실행  
  2. 이후 서비스가 실행을 시작할 때 onStartCommand 메소드가 호출되며 서비스의 상태가 실행중으로 변경  
  3. 이후 stopService 메소드가 실행되면 서비스가 종료되며 onDestroy 메소드를 호출하며 서비스의 상태가 종료로 변경  
  4. 다음으로 서비스가 bindService 메소드로 실행되는 경우 서비스가 생성될 때 onBind 메소드가 호출  
  5. 다음으로 unbindService 메소드가 호출되어 바인딩이 해제되면 onUnbind 메소드가 호출  
  6. 이후 완전히 종료될 때 onDestroy 메소드가 호출  

#### 프레그먼트(fragment)의 정의와 프레그먼트 생명주기  
* 정의  
  * 프레그먼트는 액티비티의 일부분에만 배치되는 화면 및 동작을 조작하기 위한 객체  
  * 안드로이드 3.0(허니콤)에서 화면이 비교적 큰 태블릿의 등장으로 작은 단위의 화면의 생명주기 관리할 필요가 있어 추가됨  
  * 프레그먼트 매니저를 통해서 여러개의 프레그먼트를 조작할 수 있음  
  * 레이아웃 xml 파일에서 다른 뷰들과 함께 배치될 수 있음  
* 생명주기  
  * 액티비티가 생성되면 프레그먼트 매니저는 초기화(initializing)상태가 됨  
  * 프레그먼트가 매니저에 의해 추가되면 onAttach, onAttachFragment, onCreate 메소드가 차례로 실행됨  
  * 액티비티의 onCreate 메소드 호출 이후 매니저는 생성(created) 상태로 변경됨   
    * 이때 onCreateView, onViewCreated, onActivityCreated 메소드가 차례로 호출됨  
  * 액티비티의 onStart 메소드가 호출되면 매니저는 시작(started) 상태로 onStart 메소드를 호출  
  * 이후 액티비티의 onResume 메소드가 호출되면 매니저 역시 재시작(resume) 상태로 변하며 onResume 메소드를 호출  
  * 그 외 액티비티가 화면에서 보이지 않을경우 호출되는 onStop 메소드 호출 이후 매니저는 중지(stop) 상태가 되며 액티비티의 onDestroy 메소드 호출 이후 매니저는 onDestroyView 메소드를 호출  

#### 태스크(task)란 무엇인가?  
* 예를들어 어떤 앱에서 앨범 앱을 실행하는 기능이 있다면 이 앱은 두개의 앱을 실행하는 형태가 되지만 사용자 입장에서는 하나의 앱에서 화면이 전환된다고 판단  
***이와 같은 사용자 입장에서 논리적인 화면 구성의 단위를 의미***  

#### 안드로이드의 메모리 관리 방식  
* 안드로이드는 액티비티, 서비스, 리시버, 프로바이더를 실행하기 위해 앱이 실행되는 과정에서 프로세스를 생성  
* 실행중인 모든 앱은 컴포넌트가 모두 종료되어도 다음에 이 앱을 다시 실행할 가능성이 높기 때문에 프로세스를 바로 제거하지 않음  
  * 바로 종료하지 않는 이유는 앱을 실행하기 위해 프로세스를 생성하는 과정에서 딜레이가 발생하는데 이 딜레이를 줄이기 위함  
   ***따라서 사용자에 의해 다시 앱이 실행되면 남아있던 프로세스가 존재하는 경우 바로 실행***  
* 이 과정에서 쌓여있던 많은 프로세스로 인해 메모리가 부족해지는 경우 프로세스의 우선순위(사용빈도)에 따라 프로세스를 종료하여 메모리를 확보  
