소프트웨어 개발의 기초
=================
목차
-----------------

* [객체지향 기법의 개요](#객체지향-기법의-개요)  
* [객체지향 기법의 기본 원칙](#객체지향-기법의-기본-원칙)  
* [객체지향 기법의 생명 주기](#객체지향-기법의-생명-주기)  
* [아키텍처 스타일](#아키텍처-스타일)  

## 객체지향 기법의 개요  
#### 객체지향 기법  
* 객체지향 기법의 정의  
  현실 세계의 개체(사람,자동차,컴퓨터,고양이..)를 기계의 부품처럼 하나의 객체로 만들어 기계적인 부품들을 조립하여 제품을 만들 듯이  
  ***소프트웨어를 개발할 때도 객체들을 조립해서 작성할 수 있도록 하는 기법***  
* 객체지향 기법이 도입된 이유  
  * 구조적 기겁의 문제점으로 인해 소프트웨어 위기의 해결책이 필요했음  
  * 소프트웨어의 재사용 및 확장을 용이하게 함  
  * 빠른시간에 개발가능하며, 유지보수 쉬움  
  * 복잡한 구조를 단계적,계층적으로 표현하고 멀티미디어 데이터 및 병렬 처리를 지원  
  * 현실 세계를 모형화하여 사용자와 개발자가 쉽게 이해  
  * 객체 클래스 메세지로 구성  

#### 객체  
* 정의  
  * **데이터와 데이터를 처리하는 함수를 묶어 놓은** 하나의 소프트웨어 모듈  
  * 데이터  
    * **객체가 가지고 있는 정보**  
    * 속성,상태,변수,상수,자료구조라고도 함  
  * 함수  
    * **객체가 수행하는 기능, 객체가 갖는 데이터를 처리하는 알고리즘**  
    * 객체의 상태를 참조하거나 변경하는 수단  
    * **메소드,서비스,동작** 연산이라고도 함  
    * 기존의 구조적 기법에서의 **함수, 프로시져** 에 해당하는 기능  

#### 클래스  
* 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀  
* 클래스에 속한 각각의 객체를 인스턴스라 함  
* 동일 클래스로부터 생성된 객체들은 각각 다른 속성값들을 가지므로, 여러 객체들을 만들 수 있다.  
* 최상위 클래스는 상위 클래스를 갖지 않는 유일한 클래스를 의미  
* 슈퍼클래스는 특정클래스의 상위(부모)클래스 이고 서브 클래스는 특정 클래스의 하위(자식)클래스를 의미  

#### 메세지  
* 객체들 간 상호작용을 하는데 사용되는 수단, 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항  
* 구성요소  
  * 메세지를 받는 객체의 이름  
  * 객체가 수행할 메소드 이름  
  * 메소드를 수행할 때 필요한 인자 <필요할 때만 사용>  
  * 메세지를 받은 수신 객체는 요구된 메소드를 수행하여 결과를 반환  

## 객체지향 기법의 기본 원칙  
객체지향 기법의 기본원칙에는 캡슐화, 정보은닉, 추상화, 상속성, 다형성등이 있으며, 이 중 구조적 기법과 차별되는 개념은 ***캡슐화,상속성,다형성***  
* 캡슐화  
  * ***데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미***  
  * 캡슐화된 객체들은 재사용이 용이  
  * 인터페이스가 단순해지고, 객체간의 결합도가 낮아짐(약한 결합,강한 응집의 특징을 가져야 좋은 소프트웨어)  
  * 캡슐화된 객체의 세부 내용이 외부에 은폐(정보 은닉)되어, 변경이 발생할 때 오류의 파급 효과가 적음  
    * ***cf) 정보은닉***  
      * 캡슐화에서 가장 중요한 개념  
      * **다른 객체에게 자신의 정보를 숨기고자 자신의 연산만을 통하여 접근을 허용**  
      * 외부 객체가 특정 객체의 데이터와 함수를 직접 접근하여 사용하거나 변경불가 -> 유지보수와 소프트웨어 확장 시 오류 최소화  
* 상속성  
  * ***이미 정의된 상위 클래스(부모클래스)의 모든 속성과 연산을 하위 클래스가 물려받는 것***  
  * 상속을 이용하면 하위클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스내에서 **다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있음**  
  * 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가해 사용가능  
  * 상위 클래스의 속성과 연산을 하위 클래스가 공유할 수 있기 때문에,  
  **객체와 클래스의 재사용, 즉 소프트웨어 재사용을 증대시키는 중요한 개념**  
  * ***cf)다중 상속***  
    * 한 개의 클래스가 두 개 이상의 상위클래스로부터 속성과 연산을 상속받는 것  
* 다형성
  * ***하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것***
  * 객체(클래스)들은 동일한 메소드 사용, 같은 의미의응답

## 객체지향 기법의 생명 주기  
#### 생명주기의 개요   
* 객체지향 기법을 사용해 개발하는 SW의 가장 큰 특징은 각 과정에서 사용되는 ***객체,메소드,클래스,속성등이 동일한 개념으로 사용됨***   
* 개발 전 과정에 걸쳐 <u>동일한 방법론과 표현기법이 적용</u>되는 장점이 있음    
* 같은 용어와 개념을 사용하기 때문에,  
  분석,설계,구현단계 사이의 전환이 쉽다.  
* 객체지향의 기법의 생명주기는  
  ***계획 및 분석 -> 설계 -> 구현 -> 테스트 및 검증 과정*** 으로 이뤄짐  

#### 객체지향 분석(OOA : Object Oriented Analysis)  
* 사용자의 요구사항을 분석, 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과, 메소드, 그들간의 관계등을 정의하여 모델링하는 작업  
  * 소프트웨어 개발을 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어 분석  
  * 분석가에게 주요한 모델링 구성 요소인 클래스 객체 속성 연산들을 표현해 문제를 모형화 할 수 있게 함  
  * ***클래스로부터 인스턴스화 되고, 이 클래스를 식별하는 것이 객체지향분석의 주 목적***  
  * Rumbaugh, Boach, Jacobson, Coad, Yourdon, Wirfs_Brocks 등의 사람들이 여러 객체 지향의 분석방법론을 창시 함  

#### 객체지향 설계(OOD : Object Oriented Design)  
* 전 단계를 통해 생성한 여러가지 분석 모델을 설계 모델로 변환하는 작업, 시스템 설계와 객체 설계를 수행  
  * 최근, 사용자 중심, 대화식 프로그램의 개발에 적합  
  * 시스템을 구성하는 객체와 속성,연산을 인식하는것이 설계단계에서 가장 중요함  
  * Rumbaugh, Boach등 객체지향 설계 방법론을 제시했으나, Rumbaugh의 객체지향 설계가 가장 많이 사용  
  * 일반적인 객체지향 설계 단계의 순서  
    * <u>문서정의 -> 요구 명세화 -> 객체연산자 정의 -> 객체 인터페이스 결정 -> 객체 구현</u>  

#### 객체지향 구현(OOI : Object Oriented Implementation)  
* 전 단계를 통해 생성한 설계 모델과 명세서를 근거로 코딩하는 과정  
* 객체지향 프로그래밍을 활용하면 용이하게 구현할 수 있다.  
* 객체는 순차적으로 또는 동시적으로 구현할 수 있음  
  * ***객체지향 프로그래밍***  
    * 객체 단위를 중심으로 하여 프로그램 개발하는 기법  
    * 현실 세계에 가까운 방식으로 프로그래밍  
    * 유지보수가 쉽고 재사용 가능한 프로그램 제작 가능  
    * 이미 개발된 프로그램을 이용해 빠르게 확장된 프로그램을 개발할 수 있음  
    * 분류  

    | 구분     | 특징     |
    | :------------- | :------------- |
    | 객체 기반 언어       | Ada,Actor와 같이 **객체의 개념만을 지원하는 언어**       |
    | 클래스 기반 언어       | Clu와 같이 **객체와 클래스의 개념을 지원하는 언어**       |
    | 객체 지향성 언어       | ***객체,클래스,상속의 개념을 모두 지원하는 언어*** 예시 : Simula, C++, Smalltalk, Objective-C, Java)         |  

#### 객체지향 테스트(OOT : Object Oriented Testing)  
테스트방법에는 4가지 방법이 있음 : 클래스 / 확인 / 시스템 / 통합  
* 클래스 테스트  
  * 캡슐화된 클래스나 객체를 검사  
* 확인 테스트  
  * 사용자 요구사항에 대한 만족 여부 검사   
* 시스템 테스트  
  * 모든 요소들이 적합하게 통합되고 올바른 기능을 수행하는지 검사  
* 통합 테스트  
  * 객체를 몇 개 결합하여 하나의 시스템으로 완성시키는 과정의 검사  
  스레드기반 / 사용기반 테스트로 구분  
    * 스레드기반  
      * 각각의 스레드가 통합되고 개별적으로 테스트  
    * 사용기반  
      * 독립 클래스를 테스트한 후, 그 다음 계층의 종속 클래스를 테스트  

## 아키텍처 스타일  
<u>기존의 시스템이나 애플리케이션을 개발자가 아닌 다른 사람이 유지보수를 해야하는경우 서로 설계 방식이 달라 코드를 분석하는데 많은 어려움이 따름</u>  
이를 해결하기 위해 많은 사람들 또는 신뢰 있는 기관에서 검증된 ***보편적인 설계 방법을 사용하는데 이를 아키텍쳐 스타일이라함***  

#### IEEE 1471  
국제 표준 아키텍쳐 스타일  
* 특징  
  * 표준화 : 아키텍쳐 관련 용어와 개념들을 통일  
  * 중립성 : 독립적인 메타 모델을 제공  
  * 유연성 : 규모에 상관없이 시스템구축에 적용 가능  
  * 의사소통 : 이해당사자 간의 의사소통을 지원, 다양한 관점에서 표현  
* 구성요소  
  *  Architectural Description  
    * 시스템 구축 시 아키텍쳐가 기록되는 방법  
  * Stakeholder  
    * 소프트웨어 시스템 개발에 관련된 모든 이해 당사자를 의미  
  * Concerns  
    * 시스템의 성능, 유지보수, 보안, 분배등과 같은 Stakeholder들의 의견과 목표  
  * View  
    * Stakeholder들이 가지는 관점, 전체 시스템을 표현하거나 묘사하는 방법  
  * Viewpoint  
    * View를 구성하기 위해 약속한 패턴  
    AD는 하나이상의 Viewpoint를 선택하여 사용  

#### 저장소 구조
* ***중앙자료구조와 독립된 컴포넌트로 구성된 아키텍쳐  
<u>큰 데이터 이동 및 공유에 적합, 컴포넌트 간의 통신은 이뤄지지않음</u>***
* 장점
  * 대량의 데이터를 저장하는데 효과적
  * 컴포넌트의 추가 삭제가 편리
  * 중앙 집중화를 통해 데이터 관리가 용이, 보안적인 측면이 뛰어남
* 단점
  * 저장소에 오류가 발생하면 시스템 전체에 문제가 발생
  * 데이터 분산의 어려움

#### MVC(Model/View/Controller Architecture)
* 정의
  * 애플리케이션을 **모델, 뷰, 컨트롤러의 세개의 컴포넌트로 구분하는 아키텍쳐**  
  ***유저 인터페이스와 비즈니스 로직들을 서로 분리하여 개발하는 방법***   
* 구성요소  
  * 모델(Model)
    * 애플리케이션의 핵심 기능을 포함
    * 상태 변화 시 컨트롤러와 뷰에 전달
  * 뷰(View)
    * 정보 표시를 관리
    * 결과물 생성을 위해 모델로부터 정보 수신
  * 컨트롤러(Controller)
    * 사용자로부터 입력을 받아 모델과 뷰에 전달
    * 모델에 명령을 전달해 상태를 변경, 뷰에 명령을 보내 표시 방법을 변경
* 적용 - [원문참고](https://opentutorials.org/course/697/3828)
  1. 사용자가 웹사이트에 접속한다. (Uses)  
  2. Controller는 사용자가 요청한 웹페이지를 서비스 하기 위해서 모델을 호출한다. (Manipulates)  
  3. 모델은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후에 그 결과를 리턴한다.  
  4. Controller는 Model이 리턴한 결과를 View에 반영한다. (Updates)  
  5. 데이터가 반영된 View는 사용자에게 보여진다. (Sees)  

  ![MVC모델의 예](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/327/1262.png)  
* 장점  
  * 동일한 모델에 대해 다양한 뷰를 제공  
  * ***효율적인 모듈화*** 가 가능  
  * 모델과 뷰의 구분으로 사용자 인터페이스에 대한 요구 사항을 적용시키는데 용이  
* 단점  
  * 간단한 애플리케이션에 적용하기에는 복잡  
  * **모델이 자주 변경되는 경우 업데이트 요청이 많이 뷰의 갱신이 따라가지 못함**  

#### 클라이언트 / 서버 구조  
* 정의  
  * 클라이언트와 서버로 나뉘는 아키텍쳐  
  * 기본적으로 하나의 서버에 다수의 클라이언트가 접속하는 일대다 관계로 구성  
  * 서버는 하나의 중앙 서버 또는 분산된 여러 서버가 존재할 수 있음  
* 구성
  * 클라이언트 : 사용자로부터 입력을 받아 서버에 요청을 전달
  * 서버 : 수신된 요청을 수행하고 데이터의 일관성을 유지
* 특징
  * **새로운 서버의 추가 및 업그레이드 용이**  
  * **데이터 관리 용이, 보안적인 측면 뛰어남**  
  * 서버에 네트워크 트래픽과 데이터 집중되 **처리비용 급중할 수 있음**  

#### 계층 구조
* **계층적으로 조직화 가능한 애플리케이션** 에 적합한 아키텍쳐
* **특정 측면만을 전문적으로 다루기 때문에 응집력 있는 설계 가능**
* 대표적으로 OSI 7계층이 있음
  * 상위 계층은 하위 계층의 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트의 입장에 선다
  * 복잡한 문제를 ***점진적이고 순차적으로 분할하여 구현할 수 있음***  
  * **인접 계층 사이에서만 요청과 응답이 이뤄짐,** 변경사항을 적용할때도 두 개의 인접 계층에만 영향을 미쳐 원활한 변경이 가능  
  * 특정 계층만을 교체해 시스템을 개선하는 것이 가능하나, **동작이 변경될 경우 단계별 재작업이 필요**
  * 구축 시 레이어의 적절한 개수나 규모를 결정하는 것에 어려움이 있음

#### 파이프 필터 구조
* 특징
  * ***데이터의 흐름을 점진적으로 처리하는 시스템을 위한 아키텍쳐***  
  * 프로세싱을 위한 시스템이 각 필터에 ***캡슐화*** 되어있음  
  * **데이터는 인접 필터 사이의 파이프를 통해 전달되는 형태**  
  * 각 필터는 **상호 독립적** 이며, 자신 앞의 필터나 뒤에 있는 필터에 대한 정보를 알 수 없음  
  * <u>모든 데이터의 처리 순서는</u> 파이프 구조와 각각의 필터를 통해 조정가능한 <u>이벤트에 의해 통제가능</u>  
* 장점
  * 설계자는 **몇 개의 필터들을 간단히 조합해 시스템의 입출력 행위를 이해할 수 있음**  
  * **새로운 필터를 기존의 구조에 추가하거나 통합하는 것이 가능**  
  * 각 필터의 **독립적인 구조** 로 인해 다양한 시스템이 적용할 수 있는 **재사용성** 을 가짐  
  * 각 필터들이 독립적인 수행이 가능해 **동시 수행으로 효율증진을 노릴 수 있음**
  * 응답성이나 데드락과 같은 특수한 분석들을 지원
* 단점
  * 상태 정보를 공유하는데 **유연하지 못함**
  * 각 필터 간 공통된 특성이 적어 각 필터가 전송받은 데이터를 다시 파싱해야하는 경우가 발생할 수 있음
